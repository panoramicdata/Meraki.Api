using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace RefitClassSourceGenerator;

[Generator(LanguageNames.CSharp)]
public sealed class RefitClassGenerator : IIncrementalGenerator
{
	private const string AttributeTypeName = "RefitPromoteCallsAttribute";

	private static readonly DiagnosticDescriptor UnexpectedErrorDescriptor = new(
		"RCG001",
		"Error",
		"Unexpected generator error: {0}",
		"Error",
		DiagnosticSeverity.Error,
		isEnabledByDefault: true);

	private static readonly DiagnosticDescriptor PropertyMissingDescriptor = new(
		"RCG002",
		"Property Missing",
		"Could not find the property {0}",
		"Error",
		DiagnosticSeverity.Error,
		isEnabledByDefault: true);

	private static readonly DiagnosticDescriptor InterfaceMissingDescriptor = new(
		"RCG003",
		"Interface Missing",
		"Could not find the interface {0}",
		"Error",
		DiagnosticSeverity.Error,
		isEnabledByDefault: true);

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
#if DEBUG
		if (!Debugger.IsAttached)
		{
			//Debugger.Launch();
		}
#endif

		var promotionCandidates = context.SyntaxProvider
			.CreateSyntaxProvider(
				static (node, _) => node is PropertyDeclarationSyntax { AttributeLists.Count: > 0 },
				static (syntaxContext, cancellationToken) => GetPromotionCandidate(syntaxContext, cancellationToken))
			.Where(static candidate => candidate is not null)!;

		context.RegisterSourceOutput(promotionCandidates.Collect(), static (sourceContext, candidates) =>
		{
			foreach (var candidate in candidates)
			{
				sourceContext.CancellationToken.ThrowIfCancellationRequested();

				if (candidate!.Diagnostic is not null)
				{
					sourceContext.ReportDiagnostic(candidate.Diagnostic);
				}

				if (candidate.Property is null)
				{
					continue;
				}

				GenerateForProperty(sourceContext, candidate.Property);
			}
		});
	}

	private static PromotionCandidate? GetPromotionCandidate(GeneratorSyntaxContext context, CancellationToken cancellationToken)
	{
		var propertySyntax = (PropertyDeclarationSyntax)context.Node;

		foreach (var attributeList in propertySyntax.AttributeLists)
		{
			foreach (var attribute in attributeList.Attributes)
			{
				var attributeConstructor = context.SemanticModel.GetSymbolInfo(attribute, cancellationToken).Symbol as IMethodSymbol;
				if (attributeConstructor?.ContainingType is not INamedTypeSymbol attributeType)
				{
					continue;
				}

				if (!string.Equals(attributeType.Name, AttributeTypeName, StringComparison.Ordinal))
				{
					continue;
				}

				if (context.SemanticModel.GetDeclaredSymbol(propertySyntax, cancellationToken) is not IPropertySymbol propertySymbol)
				{
					var diagnostic = Diagnostic.Create(
						PropertyMissingDescriptor,
						propertySyntax.GetLocation(),
						propertySyntax.Identifier.Text);
					return new PromotionCandidate(null, diagnostic);
				}

				return new PromotionCandidate(propertySymbol, null);
			}
		}

		return null;
	}

	private static void GenerateForProperty(SourceProductionContext context, IPropertySymbol propertySymbol)
	{
		try
		{
			if (propertySymbol.Type is not INamedTypeSymbol interfaceSymbol || interfaceSymbol.TypeKind != TypeKind.Interface)
			{
				context.ReportDiagnostic(
					Diagnostic.Create(
						InterfaceMissingDescriptor,
						propertySymbol.Locations.FirstOrDefault() ?? Location.None,
						propertySymbol.Type.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat)));
				return;
			}

			var interfaceMethods = interfaceSymbol
				.GetMembers()
				.OfType<IMethodSymbol>()
				.Where(static m => m.MethodKind == MethodKind.Ordinary && m.DeclaredAccessibility == Accessibility.Public)
				.ToArray();

			if (interfaceMethods.Length == 0)
			{
				return;
			}

			var builder = new StringBuilder();
			_ = builder.AppendLine("// <auto-generated />");

			var namespaceName = propertySymbol.ContainingType.ContainingNamespace.ToDisplayString();
			if (!string.IsNullOrWhiteSpace(namespaceName))
			{
				_ = builder.Append("namespace ").Append(namespaceName).AppendLine(";");
				_ = builder.AppendLine();
			}

			_ = builder.Append("public partial class ").Append(propertySymbol.ContainingType.Name).AppendLine();
			_ = builder.AppendLine("{");

			for (var index = 0; index < interfaceMethods.Length; index++)
			{
				var methodSymbol = interfaceMethods[index];
				var obsoleteAttributeText = GetObsoleteAttribute(methodSymbol);
				var methodSignature = methodSymbol.GetMethodSignature(concreteSignature: true);
				if (!string.IsNullOrWhiteSpace(obsoleteAttributeText))
				{
					_ = builder.Append('\t').AppendLine(obsoleteAttributeText);
				}

				_ = builder.Append('\t').Append(methodSignature).AppendLine();
				_ = builder.AppendLine("\t{");

				var parameters = string.Join(", ", methodSymbol.Parameters.Select(parameter => parameter.Name));
				var invocation = new StringBuilder()
					.Append(propertySymbol.Name)
					.Append('.')
					.Append(methodSymbol.Name)
					.Append('(')
					.Append(parameters)
					.Append(')')
					.ToString();

				if (!string.IsNullOrWhiteSpace(obsoleteAttributeText))
				{
					_ = builder.AppendLine("\t\t#pragma warning disable CS0618");
				}

				_ = builder.Append(methodSymbol.ReturnsVoid ? "\t\t" : "\t\treturn ");

				_ = builder.Append(invocation).AppendLine(";");

				if (!string.IsNullOrWhiteSpace(obsoleteAttributeText))
				{
					_ = builder.AppendLine("\t\t#pragma warning restore CS0618");
				}

				_ = builder.AppendLine("\t}");

				if (index < interfaceMethods.Length - 1)
				{
					_ = builder.AppendLine();
				}
			}

			_ = builder.AppendLine("}");

			var hintName = $"{propertySymbol.ContainingType.Name}_{propertySymbol.Name}.g.cs";
			context.AddSource(hintName, SourceText.From(builder.ToString(), Encoding.UTF8));
		}
		catch (Exception ex)
		{
			context.ReportDiagnostic(
				Diagnostic.Create(
					UnexpectedErrorDescriptor,
					propertySymbol.Locations.FirstOrDefault() ?? Location.None,
					ex.Message));
		}
	}

	private static string? GetObsoleteAttribute(IMethodSymbol methodSymbol)
	{
		var obsoleteAttribute = methodSymbol
			.GetAttributes()
			.FirstOrDefault(static attribute
				=> attribute.AttributeClass?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "global::System.ObsoleteAttribute");

		if (obsoleteAttribute is null)
		{
			return null;
		}

		var arguments = new List<string>();
		foreach (var argument in obsoleteAttribute.ConstructorArguments)
		{
			if (argument.Kind == TypedConstantKind.Error)
			{
				continue;
			}

			arguments.Add(argument.ToCSharpString());
		}

		var builder = new StringBuilder("[global::System.Obsolete");

		var namedArguments = obsoleteAttribute.NamedArguments;
		if (arguments.Count > 0 || namedArguments.Length > 0)
		{
			_ = builder.Append('(');

			var isFirst = true;
			foreach (var argument in arguments)
			{
				if (!isFirst)
				{
					_ = builder.Append(", ");
				}

				_ = builder.Append(argument);
				isFirst = false;
			}

			foreach (var namedArgument in namedArguments)
			{
				if (!isFirst)
				{
					_ = builder.Append(", ");
				}

				_ = builder
					.Append(namedArgument.Key)
					.Append(" = ")
					.Append(namedArgument.Value.ToCSharpString());
				isFirst = false;
			}

			_ = builder.Append(')');
		}

		_ = builder.Append(']');

		return builder.ToString();
	}

	private sealed class PromotionCandidate
	{
		public PromotionCandidate(IPropertySymbol? property, Diagnostic? diagnostic)
		{
			Property = property;
			Diagnostic = diagnostic;
		}

		public IPropertySymbol? Property { get; }

		public Diagnostic? Diagnostic { get; }
	}
}
