using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Text;

#if DEBUG
// Needed for Debugger launching
using System.Diagnostics;
#endif

namespace RefitClassSourceGenerator;

/// <summary>
/// Incremental source generator that promotes methods from Refit interfaces to containing classes
/// </summary>
[Generator]
public class RefitClassGenerator : IIncrementalGenerator
{
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		// Find all properties with the RefitPromoteCalls attribute
		var propertiesProvider = context.SyntaxProvider
			.CreateSyntaxProvider(
				predicate: static (node, _) => node is PropertyDeclarationSyntax p && p.AttributeLists.Count > 0,
				transform: static (ctx, _) => GetPropertyIfEligible(ctx))
			.Where(static p => p is not null);

		// Combine with compilation
		var compilationAndProperties = context.CompilationProvider.Combine(propertiesProvider.Collect());

		// Generate source for each property
		context.RegisterSourceOutput(compilationAndProperties, static (spc, source) => Execute(source.Left, source.Right!, spc));
	}

	private static PropertyDeclarationSyntax? GetPropertyIfEligible(GeneratorSyntaxContext context)
	{
		var propertyDeclaration = (PropertyDeclarationSyntax)context.Node;

		// Check if the property has the RefitPromoteCalls attribute
		foreach (var attributeList in propertyDeclaration.AttributeLists)
		{
			foreach (var attribute in attributeList.Attributes)
			{
				var attributeName = attribute.Name.NormalizeWhitespace().ToFullString();
				if (attributeName is "RefitPromoteCalls" or "RefitPromoteCallsAttribute")
				{
					return propertyDeclaration;
				}
			}
		}

		return null;
	}

	private static void Execute(Compilation compilation, ImmutableArray<PropertyDeclarationSyntax?> properties, SourceProductionContext context)
	{
		try
		{
#if DEBUG
			if (!Debugger.IsAttached)
			{
				//Debugger.Launch();
			}
#endif
			foreach (var property in properties)
			{
				if (property is null)
				{
					continue;
				}

				var semanticModel = compilation.GetSemanticModel(property.SyntaxTree);

				// Find the type of the property as this is what we want to copy properties from
				var propertyDeclaredSymbol = semanticModel.GetDeclaredSymbol(property);

				if (propertyDeclaredSymbol is null)
				{
					// Report an error message that we couldn't find the property
					context.ReportDiagnostic(
						Diagnostic.Create(
							new DiagnosticDescriptor(
								"RCG002",
								"Property Missing",
								$"Could not find the property {property.ToFullString()}",
								"Error",
								DiagnosticSeverity.Error,
								true),
							Location.None));
					continue;
				}

				var propertyTypeName = propertyDeclaredSymbol.Type.ToDisplayString();
				var propertyInterfaceSymbols = GetMatchingInterfacesInSolution(compilation, propertyTypeName);

				if (propertyInterfaceSymbols.Length == 0)
				{
					// Report an error message that we couldn't find the interface
					context.ReportDiagnostic(
						Diagnostic.Create(
							new DiagnosticDescriptor(
								"RCG003",
								"Interface Missing",
								$"Could not find the interface {propertyTypeName}",
								"Error",
								DiagnosticSeverity.Error,
								true),
							Location.None));
					continue;
				}

				if (propertyInterfaceSymbols.Length != 1)
				{
					// Report an error message that we found other than 1 interface
					context.ReportDiagnostic(
						Diagnostic.Create(
							new DiagnosticDescriptor(
								"RCG004",
								"Ambiguous interface reference",
								$"Found {propertyInterfaceSymbols.Length} interface symbols for {propertyTypeName}",
								"Error",
								DiagnosticSeverity.Error,
								true),
							Location.None));
					continue;
				}

				var propertyInterfaceSymbol = propertyInterfaceSymbols[0];

				// Get all the methods on the interface
				var interfaceMethodSymbols = propertyInterfaceSymbol?.GetMembers().OfType<IMethodSymbol>().ToList();
				if (interfaceMethodSymbols is null || interfaceMethodSymbols.Count == 0)
				{
					continue;
				}

				var sb = new StringBuilder(@$"
// <auto-generated />
namespace {propertyDeclaredSymbol.ContainingType.ContainingNamespace};

public partial class {propertyDeclaredSymbol.ContainingType.Name}
{{
");

				var processedAnyMethods = false;
				foreach (var methodSymbol in interfaceMethodSymbols)
				{
					if (processedAnyMethods)
					{
						sb.AppendLine();
					}

					if (methodSymbol.DeclaredAccessibility == Accessibility.Public)
					{
						// Add XML documentation comment first
						sb.AppendLine("\t/// <inheritdoc />");

						// Check for Obsolete attribute and add it after the XML comment
						var obsoleteAttribute = methodSymbol.GetAttributes()
							.FirstOrDefault(a => a.AttributeClass?.Name == "ObsoleteAttribute");
						
						if (obsoleteAttribute is not null)
						{
							// Extract the message from the Obsolete attribute if it exists
							var obsoleteMessage = obsoleteAttribute.ConstructorArguments.Length > 0
								? obsoleteAttribute.ConstructorArguments[0].Value?.ToString()
								: null;
							
							if (obsoleteMessage is not null)
							{
								sb.AppendLine($"\t[Obsolete(\"{obsoleteMessage}\")]");
							}
							else
							{
								sb.AppendLine("\t[Obsolete]");
							}
						}

						var methodSignature = methodSymbol.GetMethodSignature(true);
						sb.AppendLine("\t" + methodSignature);
						var parameters = string.Join(", ", methodSymbol.Parameters.Select(p => $"{p.Name}"));
						sb.AppendLine($"\t\t=> {propertyDeclaredSymbol.Name}.{methodSymbol.Name}({parameters});");
					}

					processedAnyMethods = true;
				}

				sb.AppendLine("}");
				var newSource = sb.ToString();
#if DEBUG
				if (!Debugger.IsAttached)
				{
					//Debugger.Launch();
				}
#endif
				context.AddSource($"{propertyDeclaredSymbol.ContainingType.Name}_{propertyDeclaredSymbol.Name}.g.cs", SourceText.From(newSource, Encoding.UTF8));
			}
		}
		catch (Exception ex)
		{
#if DEBUG
			if (!Debugger.IsAttached)
			{
				//Debugger.Launch();
			}
#endif
			context.ReportDiagnostic(
				Diagnostic.Create(
					new DiagnosticDescriptor(
						"RCG001",
						"Error",
						ex.Message,
						"Error",
						DiagnosticSeverity.Error,
						true),
					Location.None));
		}
	}

	private static ImmutableArray<INamedTypeSymbol?> GetMatchingInterfacesInSolution(Compilation compilation, string name)
		=> [.. compilation.SyntaxTrees
			.SelectMany(syntaxTree =>
			{
				var semanticModel = compilation.GetSemanticModel(syntaxTree);
				return semanticModel.SyntaxTree.GetRoot()
					.DescendantNodes()
					.OfType<InterfaceDeclarationSyntax>()
					.Select(interfaceDeclarationSyntax => semanticModel.GetDeclaredSymbol(interfaceDeclarationSyntax));
			})
			.Where(symbol => symbol != null && name == symbol.ToDisplayString())];
}
